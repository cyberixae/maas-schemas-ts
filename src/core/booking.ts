/*

undefined
The base booking object with all fields, to be inherited

!!! AUTO GENERATED BY CONVERT.TS REFRAIN FROM MANUAL EDITING !!!

*/

import * as Units_ from 'maas-schemas-ts/core/components/units';
import * as t from 'io-ts';
import * as Fare_ from 'maas-schemas-ts/core/components/fare';
import * as Cost_ from 'maas-schemas-ts/core/components/cost';
import * as Configurator_ from 'maas-schemas-ts/core/components/configurator';
import * as Common_ from 'maas-schemas-ts/core/components/common';
import * as Leg_ from 'maas-schemas-ts/core/leg';
import * as Terms_ from 'maas-schemas-ts/core/components/terms';
import * as State_ from 'maas-schemas-ts/core/components/state';
import * as StateLog_ from 'maas-schemas-ts/core/components/state-log';
import * as BookingMeta_ from 'maas-schemas-ts/core/booking-meta';
import * as Customer_ from 'maas-schemas-ts/core/customer';
import * as Product_ from 'maas-schemas-ts/core/product';
import * as CustomerSelection_ from 'maas-schemas-ts/core/components/customerSelection';

type Defined =
  | Record<string, unknown>
  | Array<unknown>
  | string
  | boolean
  | number
  | null;
const Defined = t.union([
  t.UnknownRecord,
  t.UnknownArray,
  t.string,
  t.boolean,
  t.number,
  t.null,
]);

export const schemaId = 'http://maasglobal.com/core/booking.json#';
// Id
// The purpose of this remains a mystery
export type Id = Units_.Uuid;
export const Id = Units_.Uuid;
// Fares
// The purpose of this remains a mystery
export type Fares = t.Branded<Array<Fare_.Default>, FaresBrand>;
export const Fares = t.brand(
  t.array(Fare_.Default),
  (x): x is t.Branded<Array<Fare_.Default>, FaresBrand> => true,
  'Fares',
);
export interface FaresBrand {
  readonly Fares: unique symbol;
}
// Cost
// The purpose of this remains a mystery
export type Cost = Cost_.Default;
export const Cost = Cost_.Default;
// Configurator
// The purpose of this remains a mystery
export type Configurator = Configurator_.Default;
export const Configurator = Configurator_.Default;
// TspId
// The purpose of this remains a mystery
export type TspId = t.Branded<string, TspIdBrand>;
export const TspId = t.brand(
  t.string,
  (x): x is t.Branded<string, TspIdBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 256),
  'TspId',
);
export interface TspIdBrand {
  readonly TspId: unique symbol;
}
// Leg
// MaaS response may return any subset of legCore
export type Leg = t.Branded<
  {
    signature?: Common_.Signature;
    state?: Leg_.State;
    from?: Leg_.From;
    to?: Leg_.To;
    startTime?: Leg_.StartTime;
    endTime?: Leg_.EndTime;
    mode?: Leg_.Mode;
    stops?: Leg_.Stops;
    departureDelay?: Leg_.DepartureDelay;
    arrivalDelay?: Leg_.ArrivalDelay;
    distance?: Leg_.Distance;
    route?: Leg_.Route;
    routeShortName?: Leg_.RouteShortName;
    routeLongName?: Leg_.RouteLongName;
    agencyId?: Leg_.AgencyId;
    legGeometry?: Leg_.LegGeometry;
    tspProduct?: Leg_.TspProduct;
    productOption?: Leg_.ProductOption;
  },
  LegBrand
>;
export const Leg = t.brand(
  t.partial({
    signature: Common_.Signature,
    state: Leg_.State,
    from: Leg_.From,
    to: Leg_.To,
    startTime: Leg_.StartTime,
    endTime: Leg_.EndTime,
    mode: Leg_.Mode,
    stops: Leg_.Stops,
    departureDelay: Leg_.DepartureDelay,
    arrivalDelay: Leg_.ArrivalDelay,
    distance: Leg_.Distance,
    route: Leg_.Route,
    routeShortName: Leg_.RouteShortName,
    routeLongName: Leg_.RouteLongName,
    agencyId: Leg_.AgencyId,
    legGeometry: Leg_.LegGeometry,
    tspProduct: Leg_.TspProduct,
    productOption: Leg_.ProductOption,
  }),
  (
    x,
  ): x is t.Branded<
    {
      signature?: Common_.Signature;
      state?: Leg_.State;
      from?: Leg_.From;
      to?: Leg_.To;
      startTime?: Leg_.StartTime;
      endTime?: Leg_.EndTime;
      mode?: Leg_.Mode;
      stops?: Leg_.Stops;
      departureDelay?: Leg_.DepartureDelay;
      arrivalDelay?: Leg_.ArrivalDelay;
      distance?: Leg_.Distance;
      route?: Leg_.Route;
      routeShortName?: Leg_.RouteShortName;
      routeLongName?: Leg_.RouteLongName;
      agencyId?: Leg_.AgencyId;
      legGeometry?: Leg_.LegGeometry;
      tspProduct?: Leg_.TspProduct;
      productOption?: Leg_.ProductOption;
    },
    LegBrand
  > => true,
  'Leg',
);
export interface LegBrand {
  readonly Leg: unique symbol;
}
// Terms
// The purpose of this remains a mystery
export type Terms = Terms_.Default;
export const Terms = Terms_.Default;
// Token
// The validity token (such as booking ID, travel ticket etc.) that MaaS clients will display to validate the trip when starting the leg.
export type Token = t.Branded<
  {
    validityDuration?: {
      startTime?: Units_.Time;
      endTime?: Units_.Time;
    };
    data?: {};
    meta?: {};
  },
  TokenBrand
>;
export const Token = t.brand(
  t.partial({
    validityDuration: t.partial({
      startTime: Units_.Time,
      endTime: Units_.Time,
    }),
    data: t.type({}),
    meta: t.type({}),
  }),
  (
    x,
  ): x is t.Branded<
    {
      validityDuration?: {
        startTime?: Units_.Time;
        endTime?: Units_.Time;
      };
      data?: {};
      meta?: {};
    },
    TokenBrand
  > => true,
  'Token',
);
export interface TokenBrand {
  readonly Token: unique symbol;
}
// Default
// The default export. More information at the top.
export type Default = t.Branded<
  {
    id?: Id;
    tspId?: TspId;
    state?: State_.BookingState;
    stateLog?: StateLog_.Default;
    fares?: Fares;
    cost?: Cost;
    leg?: Leg;
    token?: Token;
    meta?: BookingMeta_.Default;
    terms?: Terms;
    customer?: Customer_.Default & {
      identityId: Defined;
    };
    product?: Product_.Default;
    signature?: Common_.Signature;
    configurator?: Configurator;
    customerSelection?: CustomerSelection_.Default;
  } & {
    id: Defined;
    state: Defined;
    leg: Defined;
    meta: Defined;
    terms: Defined;
    token: Defined;
    customer: Defined;
  },
  DefaultBrand
>;
export const Default = t.brand(
  t.intersection([
    t.partial({
      id: Id,
      tspId: TspId,
      state: State_.BookingState,
      stateLog: StateLog_.Default,
      fares: Fares,
      cost: Cost,
      leg: Leg,
      token: Token,
      meta: BookingMeta_.Default,
      terms: Terms,
      customer: t.intersection([
        Customer_.Default,
        t.type({
          identityId: Defined,
        }),
      ]),
      product: Product_.Default,
      signature: Common_.Signature,
      configurator: Configurator,
      customerSelection: CustomerSelection_.Default,
    }),
    t.type({
      id: Defined,
      state: Defined,
      leg: Defined,
      meta: Defined,
      terms: Defined,
      token: Defined,
      customer: Defined,
    }),
  ]),
  (
    x,
  ): x is t.Branded<
    {
      id?: Id;
      tspId?: TspId;
      state?: State_.BookingState;
      stateLog?: StateLog_.Default;
      fares?: Fares;
      cost?: Cost;
      leg?: Leg;
      token?: Token;
      meta?: BookingMeta_.Default;
      terms?: Terms;
      customer?: Customer_.Default & {
        identityId: Defined;
      };
      product?: Product_.Default;
      signature?: Common_.Signature;
      configurator?: Configurator;
      customerSelection?: CustomerSelection_.Default;
    } & {
      id: Defined;
      state: Defined;
      leg: Defined;
      meta: Defined;
      terms: Defined;
      token: Defined;
      customer: Defined;
    },
    DefaultBrand
  > => true,
  'Default',
);
export interface DefaultBrand {
  readonly Default: unique symbol;
}

export default Default;

// Success
