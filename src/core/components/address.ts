/*

undefined
MaaS schema for address related information

!!! AUTO GENERATED BY CONVERT.TS REFRAIN FROM MANUAL EDITING !!!

*/

import * as t from 'io-ts';

export const schemaId = 'http://maasglobal.com/core/components/address.json';
// ComponentAddress
// Encoded address components in form country:Finland|state:Uusimaa|city:Helsinki|zipCode:00100|streetName:Ludviginkatu|streetNumber:6
export type ComponentAddress = t.Branded<string, ComponentAddressBrand>;
export const ComponentAddress = t.brand(
  t.string,
  (x): x is t.Branded<string, ComponentAddressBrand> =>
    typeof x !== 'string' ||
    x.match(
      "^(?:(?:(?:country:(?:\\p{L}|[,\\.:\\-`'´\\s])+)|(?:state:(?:\\p{L}|[,\\.:\\-`'´\\s])+)|(?:city:(?:\\p{L}|[,\\.:\\-`'´\\s])+)|(?:zipCode:(?:\\d{3,10}|(?:\\p{L}|\\d){2,4}(\\s(?:\\p{L}|\\d){2,4})?))|(?:streetName:[^|]+)|(?:streetNumber:\\d+))\\|?){4,6}$",
    ) !== null,
  'ComponentAddress',
);
export interface ComponentAddressBrand {
  readonly ComponentAddress: unique symbol;
}
// PlaceName
// Place name (given in autocomplete)
export type PlaceName = t.Branded<string, PlaceNameBrand>;
export const PlaceName = t.brand(
  t.string,
  (x): x is t.Branded<string, PlaceNameBrand> =>
    (typeof x !== 'string' ||
      x.match(
        '^(?:\\p{L}|\\d)(?:\\p{L}|\\d|[!-/:-@[-`{-\\xA9\\xAB-\\xB4\\xB6-\\xB9\\xBB-\\xBF\\xD7\\xF7])*(?:\\s(?:\\p{L}|\\d|[!-/:-@[-`{-\\xA9\\xAB-\\xB4\\xB6-\\xB9\\xBB-\\xBF\\xD7\\xF7])+)*$',
      ) !== null) &&
    (typeof x !== 'string' || x.length <= 255),
  'PlaceName',
);
export interface PlaceNameBrand {
  readonly PlaceName: unique symbol;
}
// FirstName
// First name of the customer (e.g. John)
export type FirstName = t.Branded<string, FirstNameBrand>;
export const FirstName = t.brand(
  t.string,
  (x): x is t.Branded<string, FirstNameBrand> =>
    (typeof x !== 'string' ||
      x.match("^(?:\\p{L})+(?:[`'´\\-\\.,]?\\s?(?:\\p{L})*)*$") !== null) &&
    (typeof x !== 'string' || x.length <= 255),
  'FirstName',
);
export interface FirstNameBrand {
  readonly FirstName: unique symbol;
}
// LastName
// Last name of the customer (e.g. Doe)
export type LastName = t.Branded<string, LastNameBrand>;
export const LastName = t.brand(
  t.string,
  (x): x is t.Branded<string, LastNameBrand> =>
    (typeof x !== 'string' ||
      x.match("^(?:\\p{L})+(?:[`'´\\-\\.,]?\\s?(?:\\p{L})*)*$") !== null) &&
    (typeof x !== 'string' || x.length <= 255),
  'LastName',
);
export interface LastNameBrand {
  readonly LastName: unique symbol;
}
// Phone
// ITU-T E.164 phone number, see https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s03.html
export type Phone = t.Branded<string, PhoneBrand>;
export const Phone = t.brand(
  t.string,
  (x): x is t.Branded<string, PhoneBrand> =>
    typeof x !== 'string' || x.match('^\\+(?:\\d){6,14}\\d$') !== null,
  'Phone',
);
export interface PhoneBrand {
  readonly Phone: unique symbol;
}
// Email
// Rough validation of a valid e-mail address, see https://davidcel.is/posts/stop-validating-email-addresses-with-regex/
export type Email = t.Branded<string, EmailBrand>;
export const Email = t.brand(
  t.string,
  (x): x is t.Branded<string, EmailBrand> =>
    (typeof x !== 'string' || x.match('^.+@.+\\..+$') !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'Email',
);
export interface EmailBrand {
  readonly Email: unique symbol;
}
// Address
// Street address (and optional number), http://www.bitboost.com/ref/international-address-formats.html
export type Address = t.Branded<string, AddressBrand>;
export const Address = t.brand(
  t.string,
  (x): x is t.Branded<string, AddressBrand> =>
    (typeof x !== 'string' ||
      x.match(
        "^(?:(?:\\p{L}|\\d)+[`'´\\(\\)\\-/,\\.]?)+(\\s?(?:\\p{L}|[\\d`'´\\(\\)\\-/,\\.])?)*$",
      ) !== null) &&
    (typeof x !== 'string' || x.length <= 255),
  'Address',
);
export interface AddressBrand {
  readonly Address: unique symbol;
}
// ZipCode
// Numeric zip code, see https://en.wikipedia.org/wiki/Postal_code
export type ZipCode = t.Branded<string, ZipCodeBrand>;
export const ZipCode = t.brand(
  t.string,
  (x): x is t.Branded<string, ZipCodeBrand> =>
    (typeof x !== 'string' || x.length >= 2) && (typeof x !== 'string' || x.length <= 64),
  'ZipCode',
);
export interface ZipCodeBrand {
  readonly ZipCode: unique symbol;
}
// CountryName
// Alphabetic country name
export type CountryName = t.Branded<string, CountryNameBrand>;
export const CountryName = t.brand(
  t.string,
  (x): x is t.Branded<string, CountryNameBrand> =>
    (typeof x !== 'string' || x.match('^(?:\\p{L}|\\s)+$') !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'CountryName',
);
export interface CountryNameBrand {
  readonly CountryName: unique symbol;
}
// Country
// ISO 3166-1 alpha-2 country code, see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
export type Country = t.Branded<string, CountryBrand>;
export const Country = t.brand(
  t.string,
  (x): x is t.Branded<string, CountryBrand> =>
    typeof x !== 'string' || x.match('^[A-Z]{2,2}$') !== null,
  'Country',
);
export interface CountryBrand {
  readonly Country: unique symbol;
}
// City
// Alphabetic city name
export type City = t.Branded<string, CityBrand>;
export const City = t.brand(
  t.string,
  (x): x is t.Branded<string, CityBrand> =>
    (typeof x !== 'string' || x.match("^(?:\\p{L}|[\\s`'´])+$") !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'City',
);
export interface CityBrand {
  readonly City: unique symbol;
}

// Success
